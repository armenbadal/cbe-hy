
# Կոնտեքստից ազատ լեզուների վերլուծությունը

## Ռեկուրսիվ վայրէջքի եղանակը

Կանոնավոր լեզուները սահմանափակ են նրանով, որ չեն կարող արտահայտել ներդրված կառուցվծաքներ։ Ներդրված կառուցվածքները կարող են արտահայտվել միայն ռեկուրսիայի օգնությամբ (տես Գլուխ 2)։

Այդ պատճառով էլ վերջավոր ավտոմատների ապարատը բավարար չէ կոնտեքստից ազատ լեզուները ճանաչելու համար։ Այնուամենայնիվ, կփորձենք շարահյուսական անալիզատոր կառուցել 2-րդ գլխի 3-րդ օրինակի համար՝ 3-րդ գլխում բացատրված եղանակն օգտագործելով։ Որտեղ որ այդ եղանակը ձախողվի, իսկ այն պետք է ձախողվի, գտնվում է հնարավոր ընդհանրացման բանալին։ Իսկապես զարմանալի է, թե ինչքան քիչ ջանք է պետք դա անելու համար։

Հետևյալ կառուցվածքում.

A  =  "a" A "c" | "b".

սովորական պարզեցումներից և `CASE` հրամանն `IF` հրամանով փոխարինելուց հետո ստացվում է ծրագրի այս կտորը.

````
IF sym = "a" THEN
  next;
  IF sym = A THEN next ELSE error END;
  IF sym = "c" THEN next ELSE error END
ELSIF sym = "b" THEN next
ELSE error
END
````

Այստեղ `A` ոչ֊տերմինալային սիմվոլի հետ կուրորեն վարվեցինք ինչպես տերմինալային սիմվոլ։ Սա, իհարկե, թույլատրելի չէ։ Ծրագրի երրորդ տողի նպատակը `A` կառուցվածքի վերլուծությունն է (այլ ոչ թե `A` սիմվոլը կարդալը)։ Սակայն դա նաև մեր ամբողջ ծրագրի նպատակն է։ Այդպիսով, մեր խնդրի պարզ լուծումն է․ ծրագրին անուն տալ, այսինքն՝ ծրագրին տալ պրոցեդուրայի ձև, և նրա երրորդ տողը փոխարինել այդ պրոցեդուրայի կանչով։ Ճիշտ այնպես, ինչպես `A` կառուցվածքն է ռեկուրսիվ, այնպես էլ `A` պրոցեդուրան է ռեկուրսիվ։

````
PROCEDURE A;
BEGIN
  IF sym = "a" THEN
    next; A;
    IF sym = "c" THEN next ELSE error END
  ELSIF sym = "b" THEN next
  ELSE error
  END
END A
````

Թարգմանության կանոնների բազմության անհրաժեշտ ընդլայնումը չափազանց պարզ է։ Միակ լրացուցիչ կանոնը հետևյալն է.

> Ամեն մի ոչ֊տերմինալային սիմվոլի համար դուրս է բերվում վերլուծության ալգորիթմ և այն ձևակերպվում է որպես տվյալ սիմվոլի անունն ունեցող պրոցեդուրա։ Շարահյուսության մեջ սիմվոլի հանդիպելը թարգմանվում է համապատասխան պրոցեդուրայի կանչի։

Նշենք, որ այս կանոնը ճիշտ է՝ անկախ պրոցեդուրայի ռեկուրսիվ լինելուց։

Կարևոր է ստուգել, որ պահպանված են ալգորիթմի դետերմինացված լինելու պայմանները։ Սա նշանակում է, ի թիվս այլ բաների, որ 

term0 | term1

տեսքի արտահայտության մեջ `term`-երը չպետք է ունենան որևէ ընդհանուր սկզբնական սիմվոլներ։ Այս պահանջը բացառում է ձախակողմյան ռեկուրսիան։ Եթե դիտարկենք ձախակողմյան ռեկուրսիա ունեցող հետևյալ արտածումը.

A  =  A "a" | "b".

կնկատենք, որ պահանջը խախտված է հենց միայն այն պատճառով, որ `b`-ն `A`-ի սկզբնական սիմվոլ է (`b IN first(A)`), և հետևաբար `first(A"a")`-ն և `first("b")`-ն հատվում են։ `"b"`-ն նրանց ընդհանուր տարր է։

Պարզ հետևություն. ձախակողմյան ռեկուրսիան կարելի է և պետք է փոխարինել կրկնությունով։ Վերը բերված օրինակում `A  =  A "a" | "b"` հավասարումը փոխարինված է `A = "b" {"a"}` հավասարումով։

Վերջավոր ավտոմատի ընդհանրացմանը տանող քայլի մեկ այլ տեսակետն այն է, որ ընդհանրացումը ներկայացվի որպես վերջավոր ավտոմատների բազմություն, որոնք հղվում են մեկը մյուսին և իրենք իրենց։ Սկզբունքորեն, միակ նոր պայմանն այն է, որ կանչող ավտոմատի վիճակը վերականգնվում է կանչված ավտոմատի աշխատանքի ավարտից հետո։ Հետևաբար, վիճակը պետք է պահպանվի։ Քանի որ ավտոմատները ներդրված են, ստեկն ամենահարմար հիշողությունն է։ Այդ պատճառով էլ վերջավոր ավտոմատի մեր ընդլայնումը կոչվում է _պահունակով ավտոմատ_։ Տեսականորեն կարևոր է, որ ստեկը (պահունակային հիշողությունը) ունենա անվերջ խորություն։ Սա է վերջավոր ավտոմատի և անվերջ պահունակով ավտոմատի սկզբունքային տարբերությունը։

Ընդհանուր սկզբունքը, որ այստեղ առաջարկվում է, հետևյալն է. որպես գլխավոր նպատակ դիտարկեք հիմնական շարահյուսության սկզբնական սիմվոլով սկսվող սենտենցիալ կառուցվծաքի ճանաչումը։ Եթե այդ նպատակին հասնելու ընթացքում, այսինքն՝ արտածման վերլուծության ժամանակ, հանդիպում է ոչ տերմինալային սիմվոլ, ապա այդ սիմվոլին համապատասխան կառուցվածքի ճանաչումը դիտարկվում է որպես ենթանպատակ, որի կատարման ժամանակ հիմնական նպատակի կատարումը ժամանակավորապես դադարեցվում է։ Այս ստրատեգիան կոչվում է նաև նպատակին-կողմնորշված վերլուծություն։ Եթե ուշադրություն դարձնենք վերլուծված նախադասության կառուցվածքային ծառին, կտեսնենք, որ ծառում ավելի վերև գտնվող նպատակները (սիմվոլներ) դիտարկվել են ավելի վաղ, քան ավելի ներքև գտնվող նպատակները (սիմվոլները)։ Այս մեթոդը կոչվում է _վայրընթաց վերլուծություն_ (Knuth, 1971; Aho և Ullman, 1977)։ Ավելին, ռեկուրսիվ պրոցեդուրաների վրա հիմնված այդ ստրատեգիայի ներկայացված իրականացումը հայտնի է որպես _վերլուծության ռեկուրսիվ վայրէջքի_ եղանակ։

Վերջապես, հիշենք, որ հերթական կատարվելիք քայլը միշտ որոշվում է միայն մեկ հաջորդ կարդացված սիմվոլի հիման վրա։ Շարահյուսական անալիզատորը առաջ է նայում միայն մեկ սիմվոլով։ Մի քանի սիմվոլներով առաջ նայելը էապես կբարդացնի որոշում կայացնելու պրոցեսը՝ դրանով իսկ դանդաղեցնելով այն։ Այս պատճառով էլ մեր ուշադրությունը կսահմանափակենք այն լեզուներով, որոհք կարելի է վերլուծել միայն մեկ սիմվոլ առաջ նայելով։

Շարահյուսական վերլուծության ռեկուրսիվ վայրէջքի եղանակը ցուցադրելու համար դիտարկենք EBNF-ի, որի շարահյուսությունը ևս մի անգամ ամփոփված է ստորև, շարահյուսական վերլուծիչը.

````
syntax     = {production}.  
production = identifier "=" expression ".".  
expression = term {"|" term}.  
term       = factor {factor}.  
factor     = identifier | string | "(" expression ")"  
           | "[" expression "]" | "{" expression "}".  
````

Կիրառելով տրված թարգմանության կանոնները և հետագա պարզեցումները, կստանանք հետևյալ վերլուծիչը։ Այն ձևակերպված է որպես Oberon մոդուլ․

````
MODULE EBNF;
    IMPORT Viewers, Texts, TextFrames, Oberon;
    CONST IdLen = 32;
        ident = 0; literal = 2; lparen = 3; lbrak = 4; lbrace = 5; bar = 6; eql = 7;
        rparen = 8; rbrak = 9; rbrace = 10; period = 11; other = 12;
    TYPE Identifier = ARRAY IdLen OF CHAR;
    VAR ch: CHAR;
        sym: INTEGER;
        lastpos: LONGINT;
        id: Identifier;
        R: Texts.Reader;
        W: Texts.Writer;
    PROCEDURE error(n: INTEGER);
        VAR pos: LONGINT;
    BEGIN pos := Texts.Pos(R);
        IF pos > lastpos+4 THEN  (*avoid spurious error messages*)
            Texts.WriteString(W, "  pos"); Texts.WriteInt(W, pos, 6);
            Texts.WriteString(W, "  err"); Texts.WriteInt(W, n, 4); lastpos := pos;
            Texts.WriteString(W, "  sym "); Texts.WriteInt(W, sym, 4);
            Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
        END
    END error;
    PROCEDURE GetSym;
    BEGIN ...  (*see Chapter 3*)
    END GetSym;
    PROCEDURE record(id: Identifier; class: INTEGER);
    BEGIN (*enter id in appropriate list of identifiers*)
    END record;
    PROCEDURE expression;
        PROCEDURE term;
            PROCEDURE factor;
            BEGIN
                IF sym = ident THEN record(id, 1); GetSym
                ELSIF sym = literal THEN record(id, 0); GetSym
                ELSIF sym = lparen THEN
                    GetSym; expression;
                    IF sym = rparen THEN GetSym ELSE error(2) END
                ELSIF sym = lbrak THEN
                    GetSym; expression;
                    IF sym = rbrak THEN GetSym ELSE error(3) END
                ELSIF sym = lbrace THEN
                    GetSym; expression;
                    IF sym = rbrace THEN GetSym ELSE error(4) END
                ELSE error(5)
                END
            END factor;
        BEGIN (*term*) factor;
            WHILE sym < bar DO factor END
        END term;
    BEGIN (*expression*) term;
        WHILE sym = bar DO GetSym; term END
    END expression;
    PROCEDURE production;
    BEGIN (*sym = ident*) record(id, 2); GetSym;
        IF sym = eql THEN GetSym ELSE error(7) END ;
        expression;
        IF sym = period THEN GetSym ELSE error(8) END
    END production;
    PROCEDURE syntax;
    BEGIN
        WHILE sym = ident DO production END
    END syntax;
    PROCEDURE Compile*;
    BEGIN (*set R to the beginning of the text to be compiled*)
        lastpos := 0; Texts.Read(R, ch); GetSym; syntax;
        Texts.Append(Oberon.Log, W.buf)
    END Compile;
BEGIN Texts.OpenWriter(W)
END EBNF.
````


## Աղյուսակով ղեկավարվող վայրընթաց վերլուծություն

Ռեկուրսիվ վայրէջքի եղանակը վերից-վար շարահյուսական վերլուծության սկզբունքի իրականացման մի քանի եղանակներից միայն մեկն է։ Այստեղ կներկայացնենք մեկ այլ եղական՝ աղյուսակով ղեկավարցող շարահյուսական վերլուծությունը։

Վայրընթաց շարահյուսական վերլուծության համար մեկ ընդհանուր ալգորիթմի կառուցումը, որն ընտրված շարահյուսությունը ստանում է որպես արգումենտ, այնքան էլ մտացածին չէ։ Շարահյուսությունն ընդունում է տվայլների կառուցվածքի տեսք՝ սովորաբար ներկայացված որպես աղյուսակ կամ գրաֆ։ Ապա այս տվյալների կառուցվածքը մեկնաբանվում է վերլուծությոն ընդհանուր ալգորիթմի կողմից։ Եթե ներկայացված է որպես գրաֆ, ապա մեկնաբանումը կդիտարկենք որպես մուտքային տեքստով ղեկավարվող գրաֆով անցում։ {??}

Նախ՝ պետք է որոշենք կառուցվածքային գրաֆի տվյալների ներկայացումը։ Գիտենք, որ EBNF-ը պարունակում երկու կրկնությունների կառուցվածք՝ `factor`-ների շղթա և `term`-երի շղթա։ Բնական կլինի դրանք ներկայացնել որպես ցուցակ։ Տվյալների կառուցվածքի ամեն մի տարրը ներկայացնում է (տերմինալային) սիմվոլ։ Հետևաբար, ամեն մի տարր պետք է ունենա իր երկու ժառանգներին ցույց տվող ցուցիչներ։ Դրանցից մեկը կանվանենք `next` ― հերթական `factor` սիմվոլի համար, իսկ մյուսը՝ `alt` ―  հերթական այլընտրանքային `term` սիմվոլի համար։ Oberon լեզվով գրառենք տվյալների տիպերի հետևյալ հայտարարությունները․

````
Symbol = POINTER TO SymDesc;
SymDesc = RECORD alt, next: Symbol END
````

Այնուհետև այս աբստրակտ տվյալների տիպը ձևակերպենք տերմինալային և ոչ տերմինալային սիմվոլների համար՝ օգտագործելով Oberon-ի տիպի ընդլայնման հնարավորությունը (Reiser and Wirth, 1992)։ Տերմինալային սիմվոլները ներկայացնող գրառումը պարունակում է լրացուցիչ `sym` դաշտը․

````
Terminal = POINTER TO TSDesc;
TSDesc = RECORD (SymDesc) sym: INTEGER END
````

Ոչ տերմինալային սիմվոլները ներկայացնող տարրերը հղում (ցուցիչ) են պարունակում այդ սիմվոլը պարունակող տվյալների կառուցվածքի վրա։ Գործնական դիտարկումներից ելնելով ներմուծում ենք անուղակի հղում․ ցուցիչը հղվում է լրացուցիչ վերնագրային տարրին, որն էլ իր հերթին հղվում է տվյալների կառուցվծաքին։ Վերնագիրը պարունակում է նաև կառուցվածքի անունը, այն է՝ ոչ տերմինալային սիմվոլի անունը։ Ճիշտն ասած, այս լրացումն անհրաժեշտ չէ․ դրա պիտանիությունը պարզ կդառնա քիչ ավելի ուշ։

````
Nonterminal = POINTER TO NTSDesc;
NTSDesc = RECORD (SymDesc) this: Header END
Header = POINTER TO HDesc;
HDesc = RECORD sym: Symbol;  name: ARRAY n OF CHAR END
````

Որպես օրինակ ընտրենք պարզ արտահայտությունների հետևյալ շարահյուսությունը։ Նկար 4․1-ում պատկերված է համապատասխան տվյալների կառուցվածքը որպես գրաֆ։ Հորիզոնական գծերը `next` ցուցիչներն են, իսկ ուղղահայացները՝ `alt` ցուցիչները։

````
expression = term {("+" | "-") term}.
term       = factor {("*" | "/") factor}.
factor     = id | "(" expression ")" .
````

Հիմա արդեն կարքող ենք վերլուծության ընդհանուր ալգորիթմը գրել կոնկրետ պրոցեդուրայի տեսքով․

````
PROCEDURE Parsed(hd: Header): BOOLEAN;
  VAR x: Symbol; match: BOOLEAN;
BEGIN x := hd.sym; Texts.WriteString(Wr, hd.name);
  REPEAT
    IF x IS Terminal THEN
      IF x(Terminal).sym = sym THEN match := TRUE; GetSym
      ELSE match := (x = empty)
      END
    ELSE match := Parsed(x(Nonterminal).this)
    END;
    IF match THEN x := x.next ELSE x := x.alt END
  UNTIL x = NIL;
  RETURN match
END Parsed
````


Նկար 4.1. Շարահյուսությունը արպես տվյալների կառուցվածք

Պետք է հաշվի առնել հետևյալ նկատառումները․

1. Անվերապահորեն ընդունում ենք, թե բոլոր `term`-երն ունեն հետևյալ տեսքը․

T  =  f0 | f1 | ... | fn

որտեղ բոլոր `fk`-երը, բացի վերջինից, սկսվում են իրարից տարբեր տերմինալային սիմվոլներով։ Միայն վերջին `fn` սիմվոլը կարող է սկսվել ինչպես տերմինալային, այնպես էլ ոչ տերմինալային սիմվոլով։ Այս պայմանի առկայության դեպքում կարելի է անցնել բոլոր տարբերակներով՝ ամեն մի քայլում կատարելով միայն մեկ համեմատում։

2. Տվյալների կառուցվածքը կարող է ավտոմատ դուրս բերվել շարահյուսությունից (EBNF-ով գրված), այն է՝ շարահյուսությունը կոմպիլյացնող ծրագրով։

3. Վերը բերված պրոցեդուրայում ամեն մի ոչ տերմինալային սիմվոլի անունը հանդիսանում է նրա արդյունքը։ Վերնագրային տարրը ծառայում է հենց այս նպատակին։

4. `Empty`-ն հատուկ նախատեսված տերմինալային սիմվոլ և տարր է, որը ցուց է տալիս դատարկ հաջորդականությունը։ Այն ծառայում է կրկնություններից (ցիկլերից) դուրս գալը նշելու համար։


## Վերընթաց շարահյուսական վերլուծություն

Այստեղ ներկայացված ռեկուրսիվ վայրէջքի և աղյուսակով ղեկավարվող շարահյուսական վերլուծության երկու սկզբունքներն էլ հիմնված են վայրընթաց շահրահյուսական վերլուծության սկզբունքի վրա։ Դրանց առաջնային նպատակն է ցույց տալ, որ վերլուծվող տեքստը հնարավոր է արտածել սկզբնական սիմվոլից։ Հանդիպած բոլոր ոչ տերմինալային սիմվոլները դիտարկվում են որպես ենթանպատակներ։ Վերլուծության պրոցեսը շարահյուսական ծառը կառուցում է սկսելով սկզբնական սիմվոլից, այն է՝ վերից-վար ուղղությամբ։

Սակայն, լրացման սկզբունքի համաձայն, կարելի է գնալ նաև հակառակ՝ վերընթաց ուղղությամբ։ Տեքստն ընթաերցվում է առանց որևէ հատուկ նպատակի հետևելու։ Յուրաքանչյուր քայլից հետո ստուգվում է արդյո՞ք կարդացված ենթահաջորդականությունը համապատասխանում է որևէ սենտենցիալ կառուցվածքի, այսինքն՝ արտածման աջ կողմին։ Եթե դա այդպես է, ապա կարդացած ենթահաջորդականությունը փոխարինվում է համապատասխան ոչ տերմինալային սիմվոլով։ Ճանաչման պրոցեսը նորից բաղկացած է երկու տարբեր տեսակի քայլերի հաջորդականությունից․

1. Հերթական սիմվոլը գրել ստեկում (տեղափոխման քայլ),

2. Ըստ արտածման կանոնի ստեկի սիմվոլների հաջորդականությունը փոխարինել մեկ ոչ տերմինալային սիմվոլով (կրճատման քայլ)։

Վերընթաց շարահյուսական վերլուծությունը կոչվում է նաև «տեղափոխում-կրաճատում» (shift-reduce) վերլուծություն։ {??} Շարահյուսական կառուցվածքները նախ հավաքվում են ստեկի մեջ, ապա՝ կրճատվում են։ Շարահյուսական ծառը աճում է ներքևից դեպի վերև (Knuth, 1965; Aho and Ullman, 1977; Kastens, 1990)։

Մեկ անգամ ևս այդ պրոցեսը ցուցադրենք պարզ արտահայտությունների օրինակով։ Թող որ շարահյուսությունը հետևյալն է․

E = T | E "+" T.    expression  
T = F | T "*" F.    term  
F = id | "(" E ")". factor  

և թող ճանաչվելիք արտահայտությունն է ― `x * (y + z)`։ Վերլուծության ընթացքը ցույց տալու համար սկզբնական տեքստը բերված է աջ կողմում, իսկ ձախ կողմում թվարկված են ճանաչված կառուցվքծքները (առաջին քայլում դեռևս դատարկ {??})։ Ավելի ձախ կողմում `S` (shift) և `R` (reduce) տառերը ցույց են տալիս կիրառված գործողությունը.

````
               x * (y + z) 
S   x            * (y + z) 
R   F            * (y + z) 
R   T            * (y + z) 
S   T*             (y + z)
S   T*(             y + z) 
S   T*(y              + z) 
R   T*(F              + z) 
R   T*(T              + z) 
R   T*(E              + z) 
S   T*(E+               z) 
S   T*(E + z             ) 
R   T*(E + F             ) 
R   T*(E + T             ) 
R   T*(E                 ) 
S   T*(E) 
R   T*F 
R   T 
R   E
````

Ամենավերջում տրված սկզբնական տեքստը կրճատվում է `E` սկզբնական սիմվոլի, որը տվյալ դեպքում ճիշտ կլիներ անվանել վերջնական սիմվոլ (stop symbol)։ Ինչպես ասվեց վերևում, ձախ կողմի միջանկյալ հիշողությունը ստեկ է։

Այս ներկայացմանը համադրելու համար ստորև բերված է նույն սկզբնական տեքստի վարընթաց (վերևից-ներքև) վերլուծությունը։ Գործողությունների երկու տեսակները նշված են `M` (match) և `P` (produce, expand) տառերով։ Սկզբնական սիմվոլը `E`-ն է։

````
     E              x * (y + z) 
P    T              x * (y + z) 
P    T * F          x * (y + z) 
P    F * F          x * (y + z) 
P   id * F          x * (y + z) 
M      * F            * (y + z) 
M        F              (y + z) 
P       (E)             (y + z) 
M        E)              y + z) 
P        E + T)          y + z) 
P        T + T)          y + z) 
P        F + T)          y + z) 
P       id + T)          y + z) 
M          + T)            + z) 
M            T)              z) 
P            F)              z) 
P           id)              z) 
M             )               ) 
M
````

Ակնհայտ է, որ վերընթաց մեթոդի դեպքում կարդացված սիմվոլների հաջորդականությունը միշտ կրճատվում է իր աջ կողմից, իսկ վարընթաց մեթոդի դեպքում միշտ բացվում է (ընդլայնվում է) ամենաձախ ոչ տերմինալային սիմվոլը։ Ըստ Կնութի (Knuth) վերթընթաց մեթոդն այդ պատճառով կոչվում է LR-վերլուծություն, իսկ վարընթաց մեթոդը՝ LL-վերլուծություն։ Առաջին L-ն արտահայտում է այն փաստը, որ տեքստը կարդացվում է ձախից աջ։ Սովորաբար այս նշանակմանը տրվում է `k` պարամետրը (LL(k), LR(k))։ Այն արտահայտում է առաջ նայելիք սիմվոլների քանակը։ Մենք միշտ կընդունենք, որ `k`-ն `1` է։

Անդրադառնանք վերլուծության վերընթաց սկզբունքին։ Կոնկրետ խնդիրն է որոշել, թե հաջորդն ինչ տիպի գործողություն պետք է կատարվի, և, եթե այն կրճատման (reduce) գործողությունն է, ապա ստեկի սիմվոլներից քանիսը պետք է օգտագործվեն այդ դեպքում։ Այս հարցին պատասխանելը հեշտ չէ։ Մենք պարզապես ընդունում ենք, որ վերլուծության պրոցեսի արդյունավետությունը երաշխավորելու համար, տվյալները, որոնց հիման վրա պետք է եզրակացություն անել, պետք է ներկայացված լինեն համապատասխան ձևով։ {??} Վերընթաց անալիզատորները միշտ օգտագործում են աղյուսակներ, այսինքն՝ տվյալները կազմակերպված են աղյուսակով ղեկավարվող վերից-վար վերլուծության ժամանակ օգտագործված կառուցվածքների պես։ Ի լրումն շարահյուսությունը տվյալների կառուցվածքներով ներկայացնողների, անհրաժեշտ են նաև աղյուսակներ՝ վերլուծության հաջորդ քայլն արդյունավետ եղանակով ընտրելու համար։ Այդ պատճառով էլ, ընդհանուր դեպքում, վերընթաց վերլուծությունն ավելի խճճված ու դժվար է, քան վարընթաց վերլուծությունը։

Գոյություն ունեն վերլուծությոն տարբեր LR ալգորիթմներ։ Վերշուծվելիք շարահյուսության վրա դրանք դնում են տարբեր սահմանափակումներ։ Ինչքան մեղմե են այդ պայմանները, այնքան բարդ է վերլուծությունը։ Այստեղ հիշատակենք SLR (DeRemer, 1971) և LALR (LaLonde et al., 1971) մեթոդները՝ առանց դրանց մանրամասները քննարկելու։


4. Վարժություններ

4.1. Algol 60 լեզուն պարունակում է `v1 := v2 :=  ...  vn := e` տեսքի բազմակի վերագրումը։ Այն սահմանված է հետևյալ շարահյուսությամբ․

````
assignment   = leftpartlist expression.
leftpartlist = leftpart | leftpartlist leftpart.
leftpart     = variable ":=".
expression   = variable | expression "+" variable.
variable     = ident | ident "[" expression "]".
````

Քանի՞ սիմվոլ պետք է առաջ նայել այս շարահյուսությունը վայրընթաց սկզբունքով վերլուծելու համար։ Առաջարկեք բազմակի վերագրումների այլընտրանքային շարահյուսություն, որը կպահանջի միայն մեկ սիմվոլի ռաջ նայել։

4.2. EBNF-ի `production`, `expression`, `term` և `factor` կառուցվածքների համար որոշել սիմվոլների `first` և `follow` բազմությունները։ Այդ բազմություններն օգտագործելով ստուգել, որ EBNF շարահյուսությունը դետերմինացված է։

````
syntax     = {production}.
production = id "=" expression ".".
expression = term {"|" term}.
term       = factor {factor}.
factor     = id | string | "(" expression ")"
           | "[" expression "]" | "{" expression "}".
id         = letter {letter | digit}.
string     = """ {character} """.
````

4.3. Գրել EBNF-ի համար շարահյուսական անալիզատոր և այն ընդլայնել աղյուսակով ղեկավարմամբ շարահյուսական վերլուծության համար նախատեսված տվյալների կառուցվածքներ գեներացնող հրամաններով՝ տրված շարահյուսության համար։ {??}

