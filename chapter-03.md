
# Կանոնավոր լեզուներ

EBNF տեսքով սահմանված շարահյուսական հավասարումները նկարագրում են կոնտեքստից ազատ լեզուները։ «Կոնտեքստից ազատ» տերմինն առաջարկել է Չոմսկին և արտացոլում է այն փաստը, որ `=` նիշի ձախ կողմի սիմվոլի փոկարինումը `=` նշանի աջ կողմի արտահայտությունից դուրս բերված արտահայտությամբ՝ միշտ թույլատրելի է՝ անկախ այն բանից, թե նախադասության մեջ այդ սիմվոլն ինչ կոնտեքստում է ներկայացված։ Պարզվում է, որ կոնտեքստից ազատ լինելու (Չոմսկիի իմաստով) այս սահմանափակումը լրիվ ընդունելի է ծրագրավորման լեզուների համար, և նույնիսկ ցանկալի է։ Սակայն _մեկ այլ_ իմաստով կոնտեքստից կախվածությունը այնուամենայնիվ անխուսափելի է։ Այս թեմային կվերադառնանք 8-րդ գլխում։

Այստեղ մեր նպատակն է ուսումնասիրել ոչ թե կոնտեքստից ազատ լեզուներն ընդհանրապես, այլ միայն նրա մի ենթադասը։ Այդ ենթադասը, որ հայտնի է _կանոնավոր լեզուներ_ անվանումով, նշանակալի դեր է խաղում ծրագրավորման լեզուների ոլորտում։ Ըստ էության, դրանք կոնտեքստից ազատ լեզուներ են, որոնց շարահյուսությունը ռեկուրսիա չի պարունակում, չհաշված կրկնման գործողությունը։ Քանի որ EBNF-ում կրկնությունը սահմանված է ուղղակի և առանց ռեկուրսիայի, ապա կարելի է տալ հետևյալ պարզ սահմանումը.

> Լեզուն *կանոնավոր* է, եթե նրա շարահյուսությունը հնարավոր է ներկայացնել մեկ EBNF արտահայտությամբ։

Միայն մեկ հավասարության բավարար լինելու պայմանը նաև ենթադրում է, որ արտահայտության մեջ հանդիպում են միայն տերմինալային սիմվոլներ։ Այսպիսի արտահայտությունը կոչվում է _կանոնավոր արտահայտություն_։

Կանոնավոր լեզուների երկու փոքր օրինակ թերևս բավարար է։ Առաջինը սահմանում է իդենտիֆիկատորները, որ շատ լեզուներում են հանդիպում, իսկ երկրորդը սահմանում է տասական գրառմամբ ամբողջ թվերը։ Համառոտության համար կօգտագործենք `letter` և `digit` ոչ տերմինալային սիմվոլները։ Դրանցից կարելի է ազատվել փոխարինումներով, և արդյունքում `identifier`-ը և `number`-ը կդառնան կանոնավոր արտահայտություններ։

````
identifier  =  letter {letter | digit}.
integer  =  digit {digit}.
letter  =  "A" | "B" | ... | "Z". 
digit  =  "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9".
````

Կանոնավոր լեզուների նկատմամբ մեր հետաքրքրությունը բացատրվում է նրանով, որ կանոնավոր նախադասությունները ճանաչող ծրագրերը շատ պարզ և արդյունավետ են։ «Ճանաչել» ասելով հասկանում ենք նախադասության կառուցվածքի որոշումը, դրանով իսկ պարզելով արդյո՞ք նախադասությունը ճիշտ է կառուցված, այն է՝ պատկանո՞ւմ է այն լեզվին։ Նախադասության ճանաչումը կոչվում է _շարահյուսական վերլուծություն_։

Կանոնավոր նախադասությունները ճանաչելու համար անհրաժեշտ է և բավարար ունենալ վերջավոր ավտոմատ, որը նաև կոչվում է _վիճակներով մեքենա_ (state machine)։ Ամեն մի քայլում ավտոմատը կարդում է հաջորդ նիշը և փոխում է վիճակը։ Հերթական վիճակը միարժեքորեն որոշվում է նախորդ վիճակով և կարդացած նիշով։ Եթե հերթական վիճակը միակն է, ապա ավտոմատը _դետերմինացված_ է, հակառակ դեպքում՝ _ոչ-դետերմինացված_։ Եթե ավտոմատն իրականացված է ծրագրի տեսքով, ապա վիճակը որոշվում է ծրագրի կատարման ընթացիկ կետով։

Վերլուծող ծրագիրը կարող է ուղղակիորեն դուրս բերվել շարահյուսության EBNF սահմանումից։ EBNF-ի ամեն մի K կառուցվածքի համար գոյություն ունի թարգմանության կանոն, որը վերադարձնում է ծրագրի Pr(K) հատվածը։ EBNF-ից ծրագրի տեքստի թարգմանող կանոնները ներկայացված են ստորև։ Դրանցում `sym`-ը գլոբալ փոփոխական է, որը միշտ պարունակում է ծրագրի տեքստից `next` պրոցեդուրայիով կարդացած վերջին սիմվոլը։ `error` պրոցեդուրան ավարտում է ծրագրի կատարումը՝ հաղորդելով, որ մինչ այդ պահը կարդացված սիմվոլների հաջորդականությունը լեզվին չի պատկանում։

````
K                             Pr(K)
---------------------------------------------------------------------
"x"                           IF sym = "x" THEN next ELSE error END
(exp)                         Pr(exp)
[exp]                         IF sym IN first(exp) THEN Pr(exp) END
{exp}                         WHILE sym IN first(exp) DO Pr(exp) END
fac0 fac1 ... facn            Pr(fac0); Pr(fac1); ... Pr(facn
term0 | term1 | ... | termn   CASE sym OF
                                first(term0): Pr(term0)
                              | first(term1): Pr(term1)
                                ...
                              |  first(termn): Pr(termn)
                              END
````

`first(K)` բազմությունը պարունակում է բոլոր այն սիմվոլները, որոնցով կարող են սկսվել K կառուցվածքից դուրս բերված նախադասությունները։ Դա K-ն սկսող սիմվոլների բազմությունն է։ Իդենտիֆիկատորների ու թվերի երկու օրինակի համար այն այսպիսինն է.

````
first(integer) = digits = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"}
first(identifier) = letters = {"A", "B", ... , "Z"}
````

Սակայն թարգմանության այս պարզ կանոնների կիրառումը, որ տրված շարահյուսությունից գեներացնում է վերլուծող ծրագիրը, պահանջում է, որ շարահյուսությունը լինի դետերմինացված։ Այս պնդում ավելի ճիշտ կարող է ձևակերպվել հետևյալ կերպ.

K               Cond(K)
term0 | term1   `term`-երը չպետք է ունենան որևէ ընդհանուր սկզբնական սիմվոլներ։
fac0 fac1       Եթե `fac0`-ն պարունակում է դատարկ հաջորդականությունը, ապա `fac`-երը չպետք է ունենան որևէ ընդհանուր սիմվոլներ։
[exp] կամ {exp}  `exp`-ի սկզբնական սիմվոլների բազմությունները չպետք է հատվի K-ին հաջորդող սիմվոլների հետ։

Իդենտիֆիկատորների և ամբողջ թվերի համար բերված օրինակներում այս պայմանները տեղի ունեն, հետևաբար ստանում ենք դրանց ճանաչման հետևյալ ծրագրերը.

````
IF sym IN letters THEN next ELSE error END;
WHILE sym IN letters + digits DO
    CASE sym OF
        "A" .. "Z": next
      | "0" .. "9": next
    END
END
````

````
IF sym IN digits THEN next ELSE error END;
WHILE sym IN digits DO next END
````

Հաճախ ձևափոխությունների կանոնների կիրառմամբ ստացված ծրագիրը կարելի է պարզեցնել, հեռացնելով այն պայմանները, որոնք ակնհայտորեն ստուգվել են նախորդող պայմաններում։ `sym IN letters` և `sym IN digits` պայմանները սովորաբար գրվում են այսպես.

("A" <= sym) & (sym <= "Z")
("0" <= sym) & (sym <= "9")

Ծրագրավորման լեզուների համար կանոնավոր լեզուների կարևորությունը բխում է այն փաստից, որ ծրագրավորման լեզուն սովորաբար սահմանվում է երկու փուլով։ Նախ՝ նրա շարահյուսությունը սահմանվում է վերացական տերմինալային սիմվոլների տերմիններով։ Այնուհետև՝ այդ վերացական սիմվոլները սահմանվում են կոնկրետ տերմինալային սիմվոլների, ինչպիսիք են ASCII նիշերը, հաջորդականությունների տերմիններով։ Այս երկրորդ սահմանումը սովորաբար ունի կանոնավոր շարահյուսություն։ Երկու փուլերի բաժանման առավելությունն այն է, որ աբստրակտ սիմվոլների, և դրանով իսկ՝ լեզվի սահմանումն անկախ է որևէ կոնկրետ սարքավորման վրա օգտագործվող որևէ կոնկրետ նիշերի բազմության որոշակի ներկայացումից։

Այս տրոհումն ազդում է նաև կոմպիլյատորի կառուցվածքի վրա։ Շարահյուսական վերլուծության պրոցեսը հիմնված է հաջորդ աբստրակտ սիմվոլը ստանալու պրոցեդուրայի վրա։ Իր հերթին այդ պրոցեդուրան էլ հիմնված է սիմվոլների՝ մեկ կամ ավելի նիշերի հաջորդականություններով սահմանումների վրա։ Այդ վերջին պրոցեդուրան կոչվում է _լեքսիկական անալիզատոր_, իսկ այդ երկրորդ, ցածր մակարդակի շարահյուսական վերլուծությունը՝ _լեքսիական (բառային) վերլուծություն_։ Նիշերի տերմիններով սիմվոլների սահմանումը սովորաբար տրվում է կանոնավոր լեզվով, հետևաբար՝ լեքսիական անալիզատորը սովորաբար վերջավոր ավտոմատ է։

Երկու մակարդակների տարբերությունն ընդհանրացնում ենք հետևյալ կերպ.

````
Process           Input element  Algorithm  Syntax
---------------------------------------------------------
Lexical analysis  Character      Scanner    Regular 
Syntax analysis   Symbol         Parser     Context free
````

Որպես օրինակ դիտարկենք EBNF լեզվի շարահյուսական վերլուծիչի բառային վերլուծության ենթածրագիրը։ Դրա տերմինալային սիմվոլների սահմանումները հետևյալներն են.

````
symbol = {blank} (identifier | string | "(" | ")" | "[" 
       | "]" | "{" | "}" | "|" | "=" | ".").
identifier = letter {letter | digit}.
string = """ {character} """.
````

Այս կանոններից դուրս ենք բերում `GetSym` պրոցեդուրան, որն ամեն մի կանչի ժամանակ `sym` գլոբալ փոփոխականին է վերագրում հերթական կարդացած սիմվոլը ցույց տվող թվային արժեք։ Եթե սիմվոլը իդենտիֆիկատոր կամ տող է, ապա կարդացած նիշերի հաջորդականությունը վերագրվում է `id` գլոբալ փոփոխականին։ Պետք է նշել, որ բառային վերլուծիչը հաշվի է առնում նաև բացատներն ու տողերի վերջը ցույց տվող նիշերը մշակելու կանոնները։ Հիմնականում այդ կանոններն ասում են. բացատներն ու տողի վերջի սիմվոլները բաժանում են հաջորդական սիմվոլները, իսկ այլ դեպքերում անտեսվում են։ Oberon լեզվով գրված `GetSym` պրոցեդուրան օգտագործում է հետևյալ հայտարարությունները։

````
CONST IdLen = 32;
   ident = 0; literal = 2; lparen = 3; lbrak = 4; lbrace = 5; 
   bar = 6; eql = 7; rparen = 8; rbrak = 9; rbrace = 10; 
   period = 11; other = 12;
TYPE Identifier = ARRAY IdLen OF CHAR;
VAR ch: CHAR;
    sym: INTEGER;
    id: Identifier; 
    R: Texts.Reader;
````

Նկատենք, որ կարդալու վերացական գործողությունն այժմ ներկայացված է `Texts.Read(R, ch)` կոնկրետ կանչով։ `R`-ը գլոբալ հայտարարված `Reader` օբյեկտ է, որը կապված է մուտքային տեքստի հետ։ Նկատենք նաև, որ `ch` փոփոխականը պետք է գլոբալ լինի, որովհետև `GetSym` պրոցեդուրայի վերջում այն պետք է պարունակի հաջորդ սիմվոլին պատկանող առաջին նիշը։ Սա պետք է հաշվի առնել `GetSym` պրոցեդուրայի հաջորդական կանչերի ժամանակ։

````
PROCEDURE GetSym;
    VAR i: INTEGER;
BEGIN
    WHILE ~R.eot & (ch <= " ") DO Texts.Read(R, ch) END ; (*skip blanks*)
    CASE ch OF
       "A" .. "Z", "a" .. "z": sym := ident; i := 0;
            REPEAT id[i] := ch; INC(i); Texts.Read(R, ch)
            UNTIL (CAP(ch) < "A") OR (CAP(ch) > "Z");
            id[i] := 0X
    |  22X:  (*quote*)
            Texts.Read(R, ch); sym := literal; i := 0;
            WHILE (ch # 22X) & (ch > " ") DO
                id[i] := ch; INC(i); Texts.Read(R, ch)
            END ;
            IF ch <= " " THEN error(1) END ;
            id[i] := 0X; Texts.Read(R, ch)
    |  "=" : sym := eql; Texts.Read(R, ch)
    |  "(" : sym := lparen; Texts.Read(R, ch)
    |  ")" : sym := rparen; Texts.Read(R, ch)
    |  "[" : sym := lbrak; Texts.Read(R, ch)
    |  "]" : sym := rbrak; Texts.Read(R, ch)
    | "{" : sym := lbrace; Texts.Read(R, ch)
    |  "}" : sym := rbrace; Texts.Read(R, ch)
    | "|" : sym := bar; Texts.Read(R, ch)
    |  "." : sym := period; Texts.Read(R, ch)
    ELSE sym := other; Texts.Read(R, ch)
    END
END GetSym
````


3.1. Վարժություն

Կանոնավոր լեզուների նախադասությունները կարող են ճանաչվել վերջավոր ավտոմատներով։ Դրանք սովորաբար նկարագրվում են անցումների ուրվապատկերներով։ Ամեն մի հանգույցը ներկայացնում է վիճակ, իսկ ամեն մի կողը՝ վիճակից-վիճակ անցում։ Կողը նշված է անցման ժամանակ կարդացված նիշով։ Դիտարկել հետևյալ ուրվապատկերները և EBNF-ով նկարագրել համապատասխան լեզուների շարահյուսությունը։
 
